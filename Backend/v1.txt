// import express from "express";
// import cors from "cors";
// import rateLimit from "express-rate-limit";
// import { ethers } from "ethers";

// // In-memory challenge storage. For production use Redis/db!
// const challenges = {}; // { [address]: { challenge, expiresAt, used } }

// const app = express();
// const PORT = 5000;

// // Only allow trusted frontends
// const corsOptions = {
//   origin: ["http://localhost:5173", "https://your-production-frontend.com"], // edit as needed
// };

// app.use(cors(corsOptions));
// app.use(express.json());
// app.use(
//   rateLimit({
//     windowMs: 15 * 60 * 1000,
//     max: 100,
//     standardHeaders: true,
//     legacyHeaders: false,
//   })
// );

// // GET: Issue a new challenge for the address (5 minutes expiry)
// app.get("/api/challenge/:address", (req, res) => {
//   const { address } = req.params;
//   if (!/^0x[0-9a-fA-F]{40}$/.test(address)) {
//     return res.status(400).json({ error: "Invalid address" });
//   }
//   const challenge = ethers.hexlify(ethers.randomBytes(32));
//   const expiresAt = Date.now() + 5 * 60 * 1000;
//   challenges[address] = { challenge, expiresAt, used: false };
//   res.json({ challenge });
// });

// // POST: Verify challenge signature
// app.post("/api/auth", async (req, res) => {
//   const { address, signature } = req.body;

//   // Validate input format
//   if (!/^0x[0-9a-fA-F]{40}$/.test(address)) {
//     return res.status(400).json({ success: false, error: "Invalid address" });
//   }
//   if (typeof signature !== "string" || signature.length < 66) {
//     return res.status(400).json({ success: false, error: "Invalid signature" });
//   }

//   // Look up the challenge
//   const stored = challenges[address];
//   if (!stored || stored.used || stored.expiresAt < Date.now()) {
//     return res
//       .status(400)
//       .json({ success: false, error: "Invalid or expired challenge" });
//   }
//   const { challenge } = stored;

//   try {
//     const recovered = ethers.verifyMessage(challenge, signature);
//     if (recovered.toLowerCase() === address.toLowerCase()) {
//       stored.used = true;
//       // Session/token/JWT logic can go here!
//       return res.json({ success: true });
//     } else {
//       return res.json({ success: false, error: "Signature does not match address" });
//     }
//   } catch (err) {
//     return res.status(400).json({ success: false, error: "Invalid signature" });
//   }
// });

// app.listen(PORT, () => {
//   console.log(`Auth server running securely on http://localhost:${PORT}`);
// });

//----------------------


// import express from "express";
// import cors from "cors";
// import { SiweMessage } from "siwe";
// import jwt from "jsonwebtoken";
// import mongoose from "mongoose";
// import dotenv from "dotenv";
// import rateLimit, { ipKeyGenerator } from "express-rate-limit";
// import { ethers } from "ethers"; // Only for address validation and optional ENS

// dotenv.config();

// const app = express();
// const PORT = process.env.PORT || 5000;
// const JWT_SECRET = process.env.JWT_SECRET || "fallback-secret-key";

// // Connect to MongoDB Atlas
// mongoose.connect(process.env.MONGODB_URI)
//   .then(() => console.log("✅ Connected to MongoDB Atlas"))
//   .catch(err => console.error("❌ MongoDB connection error:", err));

// // MongoDB Schemas
// const UserSchema = new mongoose.Schema({
//   address: { type: String, unique: true, required: true },
//   logins: [{ timestamp: Date, ip: { type: String, default: "unknown" } }],
//   ensName: String,
//   createdAt: { type: Date, default: Date.now },
// });
// const User = mongoose.model("User", UserSchema);

// const ChallengeSchema = new mongoose.Schema({
//   address: { type: String, required: true },
//   challenge: { type: String, required: true },
//   expiresAt: { type: Date, required: true },
//   used: { type: Boolean, default: false },
// });
// // Auto-remove expired challenges
// ChallengeSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
// const Challenge = mongoose.model("Challenge", ChallengeSchema);

// // Middleware
// app.use(cors({ origin: ["http://localhost:5173"] }));
// app.use(express.json());

// // Configure trust proxy
// app.set("trust proxy", 1);

// // Rate limiting
// const limiter = rateLimit({
//   windowMs: 15 * 60 * 1000,
//   max: 100,
//   keyGenerator: (req, res) => {
//     return req.params.address || ipKeyGenerator(req, res);
//   },
//   standardHeaders: true,
//   legacyHeaders: false,
// });
// app.use(limiter);

// // Exempt /api/register-ip
// app.use((req, res, next) => {
//   if (req.path === '/api/register-ip') {
//     return next();
//   }
//   next();
// });

// // GET: Issue SIWE challenge
// app.get("/api/challenge/:address", async (req, res) => {
//   const { address } = req.params;
//   if (!ethers.isAddress(address)) {
//     return res.status(400).json({ error: "Invalid Ethereum address" });
//   }

//   try {
//     const nonce = ethers.hexlify(ethers.randomBytes(32));
//     const domain = "http://localhost:5173";
//     const uri = "http://localhost:5173";
//     const message = new SiweMessage({
//       domain,
//       address,
//       statement: "Sign in to access your account",
//       uri,
//       version: "1",
//       chainId: 1, // Ethereum mainnet for SIWE (off-chain)
//       nonce,
//     }).prepareMessage();

//     const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes
//     await Challenge.create({ address, challenge: message, expiresAt, used: false });
//     console.log(`Challenge created for ${address}: ${message}`);
//     res.json({ challenge: message });
//   } catch (err) {
//     console.error("Challenge creation error:", err);
//     res.status(500).json({ error: "Failed to generate challenge" });
//   }
// });

// // POST: Verify signature off-chain and store in Mongo
// app.post("/api/auth", async (req, res) => {
//   const { address, signature } = req.body;
//   console.log("Received auth request:", { address, signature });
//   if (!ethers.isAddress(address) || typeof signature !== "string") {
//     console.log("Validation failed:", { address, signature });
//     return res.status(400).json({ success: false, error: "Invalid input" });
//   }

//   try {
//     const stored = await Challenge.findOne({ address, used: false });
//     if (!stored) {
//       console.log("No valid challenge found for:", address);
//       return res.status(400).json({ success: false, error: "No valid challenge found" });
//     }
//     if (stored.expiresAt < new Date()) {
//       console.log("Challenge expired:", stored);
//       return res.status(400).json({ success: false, error: "Challenge expired" });
//     }

//     console.log("Using challenge for verification:", stored.challenge); // Added logging
//     const siweMessage = new SiweMessage(stored.challenge);
//     console.log("Verifying message:", stored.challenge);
//     const { data: fields } = await siweMessage.verify({ signature });
//     console.log("Verification result:", fields);

//     if (fields.address.toLowerCase() !== address.toLowerCase()) {
//       console.log("Address mismatch:", { fieldsAddress: fields.address, inputAddress: address });
//       return res.status(400).json({ success: false, error: "Signature does not match address of the message" });
//     }

//     // Mark challenge as used
//     stored.used = true;
//     await stored.save();

//     // Store or update user in MongoDB
//     let user = await User.findOne({ address });
//     const ip = req.ip || "unknown";
//     if (!user) {
//       user = await User.create({
//         address,
//         logins: [{ timestamp: new Date(), ip }],
//       });
//     } else {
//       user.logins.push({ timestamp: new Date(), ip });
//       await user.save();
//     }

//     registerIpInBackground(address, ip).catch(err => console.error("Background IP registration failed:", err));

//     // Issue JWT
//     const token = jwt.sign({ address: user.address }, JWT_SECRET, { expiresIn: "1h" });
//     res.json({ success: true, token });
//   } catch (err) {
//     console.error("Auth error:", err);
//     res.status(400).json({ success: false, error: "Signature verification failed" });
//   }
// });

// async function registerIpInBackground(address, ip) {
//   try {
//     let user = await User.findOne({ address });
//     if (!user) {
//       await User.create({
//         address,
//         logins: [{ timestamp: new Date(), ip }],
//       });
//     } else {
//       user.logins.push({ timestamp: new Date(), ip });
//       await user.save();
//     }
//   } catch (err) {
//     console.error("Background IP registration error:", err);
//   }
// }

// // POST: Register IP from frontend
// app.post("/api/register-ip", async (req, res) => {
//   const { address, ip } = req.body;
//   if (!ethers.isAddress(address) || typeof ip !== "string") {
//     return res.status(400).json({ success: false, error: "Invalid address or IP" });
//   }

//   try {
//     let user = await User.findOne({ address });
//     if (!user) {
//       user = await User.create({
//         address,
//         logins: [{ timestamp: new Date(), ip }],
//       });
//     } else {
//       user.logins.push({ timestamp: new Date(), ip });
//       await user.save();
//     }
//     res.json({ success: true, message: "IP registered successfully" });
//   } catch (err) {
//     console.error("Register IP error:", err);
//     res.status(500).json({ success: false, error: "Failed to register IP" });
//   }
// });

// // GET: User info
// app.get("/api/userinfo", async (req, res) => {
//   const token = req.headers.authorization?.split(" ")[1];
//   if (!token) return res.status(401).json({ error: "Unauthorized: No token provided" });

//   try {
//     const decoded = jwt.verify(token, JWT_SECRET);
//     const user = await User.findOne({ address: decoded.address });
//     if (!user) return res.status(404).json({ error: "User not found" });

//     res.json({
//       address: user.address,
//       loginCount: user.logins.length,
//       lastLogin: user.logins[user.logins.length - 1]?.timestamp,
//       ensName: user.ensName || null,
//     });
//   } catch (err) {
//     res.status(401).json({ error: "Invalid or expired token" });
//   }
// });

// // GET: Developer stats
// app.get("/api/stats/users", async (req, res) => {
//   try {
//     const totalUsers = await User.countDocuments();
//     const activeUsersLast30Days = await User.countDocuments({
//       "logins.timestamp": { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },
//     });
//     res.json({ totalUsers, activeUsersLast30Days });
//   } catch (err) {
//     console.error("Stats error:", err);
//     res.status(500).json({ error: "Failed to fetch stats" });
//   }
// });

// // POST: Resolve ENS name (optional with improved error handling)
// app.post("/api/resolve-ens", async (req, res) => {
//   const { address } = req.body;
//   if (!ethers.isAddress(address)) return res.status(400).json({ error: "Invalid address" });

//   if (!process.env.INFURA_KEY) {
//     console.warn("ENS resolution skipped: INFURA_KEY not provided");
//     return res.json({ ensName: null });
//   }

//   try {
//     console.log(`Attempting ENS resolution for ${address} with Infura key: ${process.env.INFURA_KEY}`);
//     const provider = new ethers.JsonRpcProvider(
//       `https://mainnet.infura.io/v3/${process.env.INFURA_KEY}`
//     );
//     await provider.getNetwork();
//     console.log("Provider initialized successfully");
//     const ensName = await provider.lookupAddress(address);
//     console.log(`ENS resolution result: ${ensName || "No ENS name found"}`);
//     if (ensName) {
//       await User.updateOne({ address }, { ensName });
//     }
//     res.json({ ensName: ensName || null });
//   } catch (err) {
//     console.error("ENS resolution error:", err);
//     if (err.code === -32700) {
//       console.error("Invalid JSON error from Infura. Check request format or Infura configuration.");
//       return res.status(500).json({
//         error: "ENS resolution failed due to invalid JSON response",
//         details: "Please verify Infura project ID and network access.",
//       });
//     }
//     res.status(500).json({ error: "ENS resolution failed", details: err.message });
//   }
// });

// app.listen(PORT, () => console.log(`Auth server running on http://localhost:${PORT}`));
